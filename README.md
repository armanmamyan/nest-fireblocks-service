# NestJS API with Fireblocks Integration

This project is a NestJS-based REST API that provides user authentication, Stripe payment handling, and subscription management. It leverages TypeORM for database operations, JWT for token-based authentication, and integrates Stripe to handle subscriptions, invoices, and payment processing.

## Features

- **User Authentication**: Sign-up, login, JWT-based authentication, and token validation.
- **Fireblocks Integration**: Manages subscriptions, invoices, and payments for users via Stripe.
- **Password Reset Functionality**: Securely resets user passwords.
- **API Documentation**: Uses Swagger for interactive API documentation.

## Table of Contents

- [Installation](#installation)
- [Environment Variables](#environment-variables)
- [Running the Application](#running-the-application)
- [Usage](#usage)
- [API Endpoints](#api-endpoints)
- [Fireblocks Integration](#fireblocks-integration)
- [License](#license)

## Installation

1. Clone the repository:
  ```bash
    git clone https://github.com/armanmamyan/nest-fireblocks-service
   cd nest-fireblocks-service
  ```
2. Install Dependencies
  ```bash
    pnpm i
  ```
## Environment Variables

Create a `.env` file in the project root and add the following environment variables:

```bash
STAGE=development  
DB_USERNAME=your_db_username  
DB_PASSWORD=your_db_password  
DB_HOST=your_db_host  
DB_PORT=5432  
DB_NAME=your_db_name  
STRIPE_SECRET=your_stripe_secret  
STRIPE_WEBHOOK_SECRET=your_stripe_webhook_secret  
PRIVATE_KEY=your_jwt_private_key
FIREBLOCKS_SIGNER_API=fireblocks_signer_api
FIREBLOCKS_VIEWER_API=fireblocks_viewer_api
FIREBLOCKS_ACC_ID=treasury_wallet_it
CMC_API_KEY=coinmarketcap_api
FIREBLOCKS_SIGNER_KEY=path_or_direct_key
FIREBLOCKS_VIEWER_KEY=path_or_direct_key
PORT=3000  
```
> **Note:** Read more about Fireblocks secret key setup structure here: https://developers.fireblocks.com/reference/typescript-sdk.


## Running the Application

1. Start the NestJS Application:
   pnpm start:local

2. Access Swagger API Documentation:
   Visit http://localhost:3000/api for an interactive API documentation generated by Swagger.


## Usage

This API provides endpoints for managing user accounts, processing payments, and managing subscriptions.

### Authentication Flow

1. Signup - Users create an account.
2. Login - Users log in and receive a JWT token for authenticated access.
3. Token Validation - Validates the user’s JWT token for session management.
4. Password Reset - Users can reset their password securely with a token-based approach.


## API Endpoints

Below is an overview of the key endpoints. For detailed information, refer to the Swagger documentation.

### Auth Routes

- POST /auth/sign-in - User login with JWT token generation.
- POST /auth/forget-password - Sends password reset token to user's email.

### User Routes

- POST /user/signup - Creates a new user.
- POST /user/update-user - Updates user details.
- GET /user - Retrieves user data.
- GET /user/validate-token - Validates JWT token expiration.

# Fireblocks Integration Guide

### Function Explanations

1.  **onModuleInit()** Initializes the Fireblocks service on module start. It calls processInstanceReading(), which reads your private keys from a secure source (e.g., an S3 bucket) and creates two Fireblocks SDK instances:
    
    *   **Signer** for creating vault accounts, initiating transfers, etc.
        
    *   **Viewer** for read-only operations.
        
2.  **processInstanceReading()** Downloads and extracts the private key files, then instantiates the Fireblocks Signer and Viewer SDKs. If something goes wrong (e.g., missing files), it logs an error.
    
3.  **createFireblocksAccountWithAssets(userId, userEmail)** Creates a Fireblocks Vault account named after the user, and then creates/activates a default list of supported assets in that account. Returns the newly created Vault account ID and the list of assets.
    
4.  **createVault(userId, userEmail)** Creates the underlying Fireblocks Vault account with a name (\_). This function is primarily used internally by createFireblocksAccountWithAssets().
    
5.  **getVaultAccountDetails(vaultAccountId)** Retrieves detailed information (balances, addresses, etc.) about a given Vault account by its ID.
    
6.  **getSupportedListOfAssets()** Fetches the list of assets supported by Fireblocks for the configured environment (testnet vs. mainnet). Useful for discovery or debugging.
    
7.  **activateVaultWallet(vaultAccountId, assetId)** Activates the wallet for a specific asset within a Vault account. Necessary for some blockchains (e.g., Stellar, Solana) that require an on-chain “activation” transaction.
    
8.  **createUserAssets(vaultAccountId, idempotencyKey?)** Creates and activates all assets in the configured “supported assets” list for a given vault. If idempotencyKey is provided, Fireblocks can ensure duplicate calls are handled safely.
    
9.  **getAccountBasedDepositAddress(vaultAccountId, assetId)** Retrieves deposit addresses for a specific asset in the user’s Vault account.Used when you want to display or store an address to receive deposits.
    
10.  **updateVaultAccountAssetBalance(vaultAccountId)** Forces an update of asset balances in the user’s Vault account. This can be used if Fireblocks’ auto-sync is slow or you want immediate confirmation of funds.
    
11.  **getTransactionFee(vaultAccountId, withdrawalDetails)** Estimates the total transaction fees for a specific withdrawal (including network fee plus an optional service fee). This helps in showing users the expected cost before they proceed.
    
12.  **processVaultAccountCardPayment(vaultAccountId, withdrawalDetails)** Initiates a transfer from a user’s Vault account to a specified address or another Vault account. Typically used when a user pays for an internal service (like a card purchase).
    
13.  **processExternalWithdrawTransaction(vaultAccountId, withdrawalDetails)** Handles a user withdrawal to an external (off-Fireblocks) address. It calculates and collects a service fee (sending it to a dedicated fee-collection account) before sending the remainder to the target address.
    
14.  **getTransactionById(transactionId)** Retrieves the status and details of a transaction by its Fireblocks ID. Helpful for polling or logging transaction outcomes.
    
15.  **getCustomerTransactions(vaultAccountId, limit, before?, after?)** Fetches transactions associated with a particular Vault account (both incoming and outgoing) in a paginated manner. This is used to generate a user’s transaction history.
    
16.  **triggerEmailNotification(body)** Listens for Fireblocks webhooks (or internally processed events), determines whether they’re deposits or withdrawals, and triggers relevant notifications or updates (e.g., deposit confirmations, withdrawal alerts, or order status updates).
    
17.  **manualUpdateVaultAccountAssetBalance(vaultAccountId, assetId, idempotencyKey)** Updates a single asset balance (instead of the entire vault), forcing Fireblocks to refresh the on-chain and off-chain data for that one asset.
    

### Omnibus Accounts vs. Vault Accounts

*   **Omnibus Account** :An omnibus account typically refers to a single address or wallet that holds multiple users’ assets in aggregate. Transactions are recorded off-chain in a separate ledger to track each user’s balance. This approach is used to minimize on-chain fees and optimize liquidity.
    
    *   **Transfers Between Omnibus Accounts**:
        
        *   Simply move funds within the same large wallet or address structure.
            
        *   Off-chain ledger entries are updated to reflect user balances.
            
        *   Actual on-chain transactions may only happen when adding or removing liquidity from the omnibus account.
            
*   **Vault Account** (as used in Fireblocks):A dedicated vault instance that’s provisioned for a single user or entity. Each user’s assets are held in an isolated Fireblocks vault, providing additional security, compliance, and clearer on-chain transparency.
    
    *   **Transfers Between Vault Accounts**:
        
        *   In the Fireblocks system, each vault has its own ID.
            
        *   Moving funds internally (vault-to-vault) still requires an on-chain or Fireblocks-level transaction.
            
        *   Fireblocks handles the signatures, fee estimation, and internal ledgering automatically.
            

### How to Transfer Between Accounts in Both Scenarios

1.  **Omnibus-to-Omnibus**
    
    *   If you maintain one omnibus account for inbound assets and another for outbound or fee collection, you’d typically do a single blockchain transaction to move funds from one omnibus address to the other when needed.
        
    *   In many cases, movement can be done off-chain if you maintain a single omnibus address with internal ledger entries.
        
2.  **Vault-to-Vault**
    
    *   Call processVaultAccountCardPayment() or a similar function that sets up a Fireblocks transaction from the source Vault ID to the destination Vault ID.
        
    *   Fireblocks ensures the transaction is signed, broadcasted, and tracked.
        
    *   The receiving vault will appear in Fireblocks with updated balances after the transaction confirms on-chain (or off-chain if it’s an internal Fireblocks movement that doesn’t require on-chain confirmation).
        

In general, **vault accounts** are recommended for end-user or high-security situations due to the transparency and security Fireblocks provides, whereas **omnibus accounts** can be more flexible for managing liquidity but require careful internal accounting and risk management.





```bash
# Read Data from a Table
SELECT * FROM "table_name";
```

## To clear all tables' data, follow these steps using the Heroku CLI and SQL commands.
```bash
# Read Data from a Table
TRUNCATE TABLE "table1", "table2", "table3" CASCADE;
```
# OR

```bash
# Clear All Tables Automatically
DO $$ DECLARE
  r RECORD;
BEGIN
  FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
    EXECUTE 'TRUNCATE TABLE ' || quote_ident(r.tablename) || ' CASCADE;';
  END LOOP;
END $$;
```


## Generate migration file based on recent local changes

1. Go to src/config/typeorm.config-migrations.ts
2. Change  url, host, port, username, password, database to Heroku DB addresses
3. run 
```bash
pnmp run migration:generate
```
4. run 
```bash
pnpm run migration:run
```
5. Push migration file to git


## Run ngrok to test 3rd party webhooks or https connections
1. Install ngrok
https://ngrok.com/download

2. Run the following command
```bash
pnmp run ngrok
```


## License

This project is licensed under the MIT License.